package nginx

import (
	"fmt"
	"strings"
	"text/template"
)

// Config represents nginx configuration
type Config struct {
	Domain      string
	ServiceName string
	Upstreams   []Upstream
	SSL         SSLConfig
	CustomConf  string
}

// Upstream represents an nginx upstream server
type Upstream struct {
	Name string
	Host string
	Port int
}

// SSLConfig represents SSL configuration
type SSLConfig struct {
	Enabled     bool
	CertPath    string
	KeyPath     string
	LetsEncrypt bool
}

// GenerateConfig generates nginx configuration
func GenerateConfig(cfg Config) (string, error) {
	tmpl := `# Generated by podlift for {{ .ServiceName }}
upstream {{ .ServiceName }} {
{{- range .Upstreams }}
    server {{ .Host }}:{{ .Port }};
{{- end }}
}

server {
    listen 80;
    server_name {{ .Domain }};

{{- if .SSL.Enabled }}
    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name {{ .Domain }};

    # SSL Configuration
    ssl_certificate {{ .SSL.CertPath }};
    ssl_certificate_key {{ .SSL.KeyPath }};
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
{{- end }}

    # Proxy to application
    location / {
        proxy_pass http://{{ .ServiceName }};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # Health check endpoint (bypass proxy for debugging)
    location /nginx-health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

{{- if .CustomConf }}
    {{ .CustomConf }}
{{- end }}
}
`

	t, err := template.New("nginx").Parse(tmpl)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf strings.Builder
	if err := t.Execute(&buf, cfg); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

// GenerateSitePath returns the nginx sites-available path
func GenerateSitePath(serviceName string) string {
	return fmt.Sprintf("/etc/nginx/sites-available/%s", serviceName)
}

// GenerateSymlinkPath returns the nginx sites-enabled path
func GenerateSymlinkPath(serviceName string) string {
	return fmt.Sprintf("/etc/nginx/sites-enabled/%s", serviceName)
}

// GenerateEnableCommand generates command to enable site
func GenerateEnableCommand(serviceName string) string {
	sitePath := GenerateSitePath(serviceName)
	symlinkPath := GenerateSymlinkPath(serviceName)
	return fmt.Sprintf("ln -sf %s %s", sitePath, symlinkPath)
}

// GenerateReloadCommand generates command to reload nginx
func GenerateReloadCommand() string {
	return "sudo nginx -t && sudo systemctl reload nginx"
}

// GenerateTestCommand generates command to test nginx config
func GenerateTestCommand() string {
	return "sudo nginx -t"
}

// GenerateInstallCommand generates command to install nginx
func GenerateInstallCommand() string {
	return "sudo apt-get update && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y nginx"
}

// GenerateCheckCommand generates command to check if nginx is installed
func GenerateCheckCommand() string {
	return "which nginx"
}

